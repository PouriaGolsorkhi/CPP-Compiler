
تحلیل پیچیدگی زمانی کد:

1. Lexer.tokenize
   - پیچیدگی: O(n * m)
   - توضیح:
     - n: طول کد ورودی.
     - m: تعداد الگوهای توکن.
     - در هر موقعیت از کد ورودی، تابع تلاش می‌کند همه الگوهای توکن را مطابقت دهد.

2. compute_follow
   - پیچیدگی: O(V + E) بر اساس نمادهای گرامر.
   - توضیح:
     - V: تعداد غیر‌پایانه‌ها در گرامر.
     - E: تعداد کل تولیدات.
     - این فرآیند شبیه یک جستجوی گراف است که روابط گرامری را تا زمان عدم تغییر پیمایش می‌کند.

3. create_parse_table
   - پیچیدگی: O(P * T)
   - توضیح:
     - P: تعداد تولیدات گرامر.
     - T: تعداد پایانه‌ها در گرامر.
     - برای هر تولید، مجموعه‌های FIRST و FOLLOW محاسبه می‌شوند.

4. save_parse_table
   - پیچیدگی: O(N * M)
   - توضیح:
     - N: تعداد غیر‌پایانه‌ها.
     - M: تعداد پایانه‌ها.
     - جدول تجزیه را به یک فایل می‌نویسد و تمام سطرها و ستون‌ها را پیمایش می‌کند.

5. display_token_table
   - پیچیدگی: O(n)
   - توضیح:
     - n: تعداد توکن‌ها.
     - یک بار تمام توکن‌ها را پیمایش کرده و آن‌ها را بر اساس نوع گروه‌بندی می‌کند.

6. predictive_parser_with_tree
   - پیچیدگی: O(n)
   - توضیح:
     - n: تعداد توکن‌ها.
     - یک عملیات تجزیه مبتنی بر پشته را شبیه‌سازی کرده و درخت تجزیه را می‌سازد.

7. map_tokens_to_grammar
   - پیچیدگی: O(n)
   - توضیح:
     - n: تعداد توکن‌ها.
     - هر توکن را به یک نماد گرامر نگاشت می‌کند.

8. bfs
   - پیچیدگی: O(V + E)
   - توضیح:
     - V: تعداد گره‌ها (نمادها) در درخت تجزیه.
     - E: تعداد یال‌ها در درخت تجزیه.
     - جستجوی سطحی (BFS) تمام گره‌ها و یال‌ها را پیمایش می‌کند.

9. ParseTreeNode.repr
   - پیچیدگی: O(V)
   - توضیح:
     - V: تعداد گره‌ها در درخت تجزیه.
     - به‌صورت بازگشتی ساختار درخت را قالب‌بندی می‌کند.

10. ParseTreeNode.add_child
    - پیچیدگی: O(1)
    - توضیح: اضافه کردن ساده یک گره فرزند به لیست.

11. ورودی اصلی و اجرا:
    - خواندن و تجزیه کد: O(n * m).
    - محاسبه مجموعه‌های FOLLOW: O(V + E).
    - ایجاد جدول تجزیه: O(P * T).
    - تجزیه ورودی: O(n).
    - جستجوی شناسه: O(V + E).
    - پیچیدگی کلی: بسته به ترکیب موارد بالا متغیر است.
